## 基本特性 ##


### shell语法 ###
  当shell读取输入时，它会进行一系列的处理操作。如果输入指示为注释的开头那么
shell就会忽略注释符号#，以及其所在行的剩余内容。否则，shell就会读取其输入将
其分为单词和操作符，并应用引用规则来选择相应的意义赋值给单词和字符。

  然后shell会将这些标记进行解释，将其翻译为命令，其他构造结构，移除特定单词
或字符的特殊含义，扩展其他单词或字符，必要的话或进行输出/入的重定向，执行指
定的命令，等待命令的退出状态，并使得退出状态为后续的检查或处理可用。

#### shell操作 ####
  以下是一个当shell读取并执行命令的相关操作的简单描述，基本上来说shell会具有
下面的操作：

	1. 从一个文件，一个为调用选项-c提供的作为参数的字符串，或者用户终端读取输
	入。
	2. 根据引用规则将其输入分为单词和操作符，这些标记通过元字符进行分割，在该
	步骤会执行别名扩展。
	3. 将上述标记翻译为简单或复合命令。
	4. 执行各种shell扩展，将扩展的标记分为文件名列表，命令和参数。
	5. 执行任意必要的重定向并从参数列表中移除重定向操作符以及其操作数。
	6. 执行命令
	7. 选择性地等待命令完成并收集其退出状态。

#### shell引用-quoting ####

	引用是用来移除特定字符或单词对于shell的特殊含义，引用可以用来让特殊字符的特
	殊处理失效，保护保留字，保护参数扩展。
	
	每个shell元字符对于shell来说都具有特殊的含义，因此在需要表示其本身的时候需要
	使用引用。当命令历史扩展工具被使用时，历史扩展字符！，需要对其进行引用来防止
	其被历史命令扩展。shell中具有3中引用机制：转义字符，单引号，双引号。

##### 转义字符 #####

	一个没有被引起来的反斜线 \ 就是bash的转义字符，它会保留紧跟其后面字符的字面
	值，但是对于newline除外。如果出现一个\newline对，并且\本身没有被引起来，此时
	\newline被作为续行处理。

##### 单引号 #####

	将字符包含在单引号内可以保留其中每个字符的字面量值，但是一个单引号不能出现在
	单引号之间，尽管具有一个前导反斜线\。

##### 双引号 #####
	包含在双引号中的字符会保留其中所有字符的字面量值，但是对于$,\，'\`' 和'!'(当
	历史扩展生效时)。 字符$,和 \`在双引号中保留它们本身的特殊含义。在双引号中的\
	在其后面跟随以下字符（$,",\,newline,`）时保留其本身的含义-转义字符，因此当双
	引号中的'\'后面跟随这些字符时，不会显示\本身。双引号中可以通过\"的方式在其中
	使用双引号本身。如果历史命令扩展生效的话，那么双引号中的！会执行命令扩展，除
	非使用了前导转义字符对其进行转义。对于\!转义，不会移除其中的反斜线\。

	双引号中的特殊参数 * 和@具有特殊的含义。

##### ANSI-C 引用 #####

	对于$'string'形式的单词会被进行特殊的处理
	
##### 特定地区的翻译 #####
	TODO
#### shell注释 ####

### shell命令 ###

	一个简单的shell命令通常由命令以及使用空格分开的参数组成。
	更加复杂的命令是通过多种方法组合的一系列简单命令，这些方法有：管道，循环，
	条件控制以及其他分组。

#### 简单命令 ####

#### 管道 ####

	一个管道是通过控制操作符“|”或“|&”分开的一系列的简单命令.管道的形式为
		[time [-p]] [!] command1 [ | or |& command2 ] ...
	管道中的每个命令的输出都会通过管道连接到下一个命令的输入，也就是每个命令
	都会读取前一个命令的输出。这个连接在通过命令指定任何重定向之前就被执行。
	
	如果使用|&，命令1的标准错误流和标准输出流会通过管道连接到命令2的输入，这
	是对2>&1 |的缩写，隐含地在由命令指定的任何重定向之后执行将标准错误流重定
	向到标准输出流。

	保留字time会在其完成之后将时间统计信息打印到管道，统计信息目前由命令执行
	消耗的时间，用户和系统消耗时间组成。
	
	-p选项会使用POSIX指定的输出格式。如果shell本身在POSIX模式中，如果time后面
	的标记以“-”开头，不会将time作为保留字对待。
	
	TIMEFORMAT变量可以用来设置时间信息显示的格式字符串。在shell内置中，shell函
	数以及管道中可以将time作为保留字使用。
	
	一个外部的time命令不会变得更容易使用。
	当shell在POSIX模式中时，time可能跟随一个newline，此时，shll显示shell以及其
	孩子执行消耗的所有用户和系统时间。TIMEFORMAT变量可能被用来指定时间信息格式。
	
	如果管道不是异步执行时，shell会等待管道中的每个命令完成。
	管道中的每个命令都是在其子shell中，管道的退出状态是管道中的最后一个命令的退
	出状态，除非pipefail选项生效。在pipefail选项

	生效时，管道的返回状态值是
	
#### 命令列表 ####
#### 复合命令 ####
##### 循环结构 ####
    1. until
        util test-commands; do consequent-commands; done
        
    2. while
        while test-commands; do consequent-commands; done
        
    3. for 
        for name [ [in [words ...] ] ; ] do commands; done
        
        for (( expr1 ; expr2 ; expr3 )) ; do commands ; done
        
##### 条件结构 #####
    
    1. if 
        if test-commands; then
            consequent-commands;
        [elif more-test-commands; then
            more-consequences;]
        [else alternate-consequents;
        fi 
        
    2. case
        case word in 
            [ [(] pattern [|pattern]...) command-list ;;]
            ...
        esac
        
    3. select
        
        select name [in words ...]; do commands; done
        
    4. ((...)
        (( expression ))
    
    5. [[...]]
        
        [[ expression ]]
##### 命令分组 #####
    1.()
        ( list )
    
    2.{}
        { list; }

#### 协同进程 ####
#### GNU并行 ####

### shell函数 ###

### shell参数 ###
#### 位置参数 ####
#### 特殊参数 ####
    
    $* 所有参数
    
    $@ 所有参数
    
    $# 参数个数
    
    $? 退出状态
    
    $- 当前选项标志

    $$ shell 进程ID
    
    $! 最近放入后台任务的进程ID
    
    $0 shell脚本文件名
    
    $_ 用来调用脚本的绝对路径名，或者被执行的脚本文件名
    



### shell扩展 ##
扩展在命令行将输入分割为标记之后开始执行，具有以下7中类型扩展：
    
    1. 括号扩展
    2. 波浪线扩展
    3. 参数和变量扩展
    4. 命令替换
    5. 算术扩展
    6. 单词分割
    7. 文件名扩展
    
扩展执行的顺序按照上述描述的顺序进行。

在有的系统上支持进程替换扩展，该扩展与2，3，4，5的执行时间相同。

只有括号扩展，单词分割和文件名扩展会改变扩展单词的数量，其他的扩展是
将单个单词扩展为单个单词， 唯一的例外是对$@的扩展和 ${name[@]}的扩展。

在所有扩展操作执行之后，引用移除动作被执行。

#### 括号扩展 ###

    括号扩展是一个生成任意字符串的机制，这个机制与文件名扩展相似，但是
    生成的文件名不应该存在，括号扩展的模式具有一个可选的序言，跟随或者
    逗号分割的字符串或者括号之间的表达式序列，然后跟随一个可选的后缀。
    序言会添加到括号中每个字符串的前缀，后缀会添加到括号中每个字符串的
    后面，扩展操作按照从左到右的顺序进行。
    
    括号扩展可以嵌套，每个扩展的字符串没有排序，默认为从左到右的顺序.
    
    一个序列表达式的形式为 {x..y[..incr]}, x 和y可以是数字或单个字符,
    incr是一个可选的增量，为整数。如果提供的是整数，那么表达式扩展为x
    和y之间的每个数字，闭区间。提供的整数可以使用0作为前缀来强制等宽显
    示。如果当x和y为0时，shell会强制所有生成的结果包含相同的数字.
    
#### 波浪号~扩展 ####

#### shell参数扩展 ####

    $字符引入了参数扩展，命令替换或者算术扩展。要扩展的参数名称或符号可
    能包含在括号中，这是可选的但是对于保护变量扩展不被其后紧跟的字符所影
    响是非常重要的。
    当使用括号时，匹配的结束括号是第一个没有被转义的}字符或者在引起来的
    字符串中，并且没有在嵌入的算术扩展中、命令替换或参数扩展中。
    
    基本的参数扩展形式为${parameter}. 参数的值会被替换，参数是一个之前描述
    的shell参数或者数组引用。括号对于位置参数的位置不止一个数字时，或者参数
    名称跟随一个字符不能将其解释为名称的一部分时。

    如果参数的第一个字符为感叹号！，它会引入一个变量间接级别，bash将之后的参
    数变量值作为变量的名称，这个变量被扩展然后其值被作后续的替换，而不是参数
    本身的值。这种被成为间接扩展，其中的例外包括了对 ${!prefix*}和 ${!name[@]}
    的扩展，感叹号必须紧跟这左边括号一边引入间接扩展

    在下面的每个例子中，单词会使用波浪号扩展，参数扩展，命令替换以及算术扩展
    
    当不需要执行子串扩展，使用下面描述的形式，即 :-。 bash会测试一个参数是unset
    或者null。忽略连接字符只会测试参数是否unset。也就是说，使用连接符号时，操
    作符会同时测试参数是否存在并且其值是否为非null，如果忽略，操作符只测试参数
    的存在性。

    ${parameter:-word}
        如果参数不存在或者为null，扩展时使用word替换，否则使用参数值替换
        
    ${parameter:=word}
        如果参数不存在或者为null，参数的值变为word，然后使用参数的值进行替换，对于
        位置参数和特殊参数不能使用这种方式赋值。
        
    ${parameter:?word}
        如果参数不存在或者为null，扩展时word会被写入到标准错误流并且shell退出，如果
    是非交互模式的话,否则就使用参数的值进行替换
    
    ${parameter:+word}
        如果参数不存在或null，不会有任何替换否则使用word扩展替换。
        
    ${parameter:offset}
    ${parameter:offset:length}
        这会当作子串引用对待,它会根据offset指定的位置开始扩展到参数值的长度的字符，
        如果参数为@，或者关联数组的名称，那么结果会有所不同。如果未指定length，那
        么扩展的值会从offset指定的位置知道参数值的结尾。length和offset是算术表达式。
        如果offset的求解值是一个小于0的值，那么该值会作为从参数值末尾的字符偏移量。
        如果length的求解值是一个小于0的值，会被解释为参数值末尾的字符串的偏移量而
        不是作为字符数量，并且其扩展结果是在offset和这个结果之间的字符。注意负数偏
        移量的负号-需要与冒号之间存在一个空格以免引起混淆:-。
    
        如果参数为@，那么结果就是从offset开始的length个位置的参数。一个负数offset作
        为相对于最大位置参数处理，所有-1对应最后的一个位置参数，如果length求值是一个
        小于0的数会出现扩展错误。
        
        如果参数是一个索引位置数组@或*，那么结果就是length个从${paramter[offset]}的
        数组成员。一个负数的offset作为数组的最大索引位置的
        
        对于关联数组的子串扩展会产生未定义的结果。
        
        子串索引是一个基于0的除非位置参数被使用，此时索引默认以1作为开始。如果offset
        为0,并且使用位置参数，$@会作为列表的前缀。
        
    ${!prefix*}
    ${!prefix@}
        扩展为具有该前缀的变量名称，使用IFS特殊变量的第一个字符分割，当使用@时，扩展
        出现的结果在双引号内，每个变量名称扩展为一个分开的单词。
    
    ${!name[@]}
    ${!name[*]}
        如果名称是一个数组变量，扩展为名称中指定的数组索引或键值列表。如果name不是一个
        数组扩展为0如果name不存在或null。当使用@时，扩展出现在双引号内，每个键值被扩展
        为分开的单词。
    
    ${#parameter}
        参数值的长度被进行扩展替换，如果参数是*或@，那么值会被位置参数的个数替换。如果
        参数是一个数组名称并却具有下标*或@，会被数组元素的个数替换。如果patameter是一个
        索引数组名成并且具有一个负数下表索引值，那么该数字被解释相对参数最大索引的相对值，
        所以负数索引值按照从后向前的方式进行索引，-1作为最后一个元素索引。
    
    ${parameter#word}
    ${parameter##word
        如果word匹配parameter值的开头，那么扩展后的结果就是对于#取删除word最小匹配后的值，
        对于##取删除word最大匹配后的值。如果参数为@或\*，那么删除操作会匹配到每个位置参数
        上，然后返回相应的结果列表值。如果参数是数组变量具有@或\*下标,那么删除操作为应用到
        数组的每个元素上然后返回新的数组。
    
    ${parameter%word}
    ${parameter%%word}
    

    ${parameter/pattern/string}
        被扩展用来产生一个模式，参数被扩展然后最长匹配的模式被使用string替换, 如果pattern以/开头，那么所有匹配的模式都会被
        string替换。正常只有第一个匹配到的被替换。如果pattern以#开始，必须开头匹配，如果pattern以%开头，必须结尾匹配。如果
        string为null，匹配的模式被删除，pattern后面的/可以忽略。如果参数为@或*，那么替换操作会应用到每个位置参数然后返回，
        如果参数为数组变量并具有@或*下标，替换操作应用到数组中的每个元素上再返回。
        
    ${parameter^pattern}
    ${parameter^^pattern}
    ${parameter,pattern}
    ${parameter,,pattern}
        扩展会改变参数中字母字符的大小写。扩展之后的每个字符被用来与pattern进行匹配测试，如果匹配就转换其大小写。pattern不应该尝试匹配多于一个字符.'^'用来将小写字母转变为大写字母，而','用来将大写字母转换为小写字母。'^^'和',,'用来对所有匹配的字符进行扩展。但是这个扩展只会匹配并转换被转换值的第一个字符。如果没有模式pattern，就会被当做一个？用来匹配每个字符。如果parameter是'@'或'*',这个修改操作会被应用到位置参数中的每个参数上然后返回。如果parameter是一个数组变量与下表'@'或'*',这个修改操作会被应用到数组中的每个元素上然后返回。

#### 命令替换 ####
	命令替换允许命令的输出来替换命令本身，当一个命令按照以下方式封装时就会出现命令替换:
	$(command) 或`command`.
	bash会通过执行命令然后使用命令的标准输出，去掉任何的newline来进行命令替换来进行扩展。嵌入式的newlines不会被删除，但是会在单词分割时移除，对于$(cat file)的命令替换可以使用一个等价但是更快的$(<file)来进行替换。
	当旧样式的反斜线形式替换被使用时，反斜线会保留其本身的字面量含义，但是当期跟随'$','`'或'\'时会有意外。第一个没有反斜线的反斜线会结束命令替换。当使用$(command)形式时，括号中的所有字符都会用来组成命令，没有任何字符会被特殊对待。
	命令替换可能会有潜逃，在使用反斜线形式的嵌套时，会使用反斜线来转义内层的反斜线。
	如果替换在双引号内、单词分割以及文件名扩展中时，不会对结果执行扩展。

#### 算术运算扩展 ####
	算数扩展允许求解算数表达式并且使用其求解结果进行替换，算数扩展的形式为
	$(( expression ))
	该表达式被当做其在双引号中一样对待，但是括号中的双引号不会被特殊处理。表达式中的所有标记会进行参数和变量扩展，命令替换以及引用移除。最后的结果会被当做算术表达式对待并求解。算数扩展可以嵌套。
	算术运算的求解会按照之后描述的规则进行执行，如果表达式不合法，bash会打印一个暗示失败的消息到标准错误流中并且没有替换出现。

#### 进程替换扩展 ####
	进程替换会在支持命令管道或者 /dev/fd 命令打开文件的方法的系统中支持，进程替换扩展具有以下形式:
	<(list)或 >(list)
	进程列表的运行会使用其输入输出连接到一个FIFO或者在 /dev/fd. 文件名称会被作为参数传递给作为扩展结果的当前命令。如果使用>(list)形式，写入文件会作为list的输入提供。如果使用<(list)形式，作为参数传入的文件会用来读取来得到list的输出。 值得注意的是在<或>与左括号之间不应该出现空格，否则这种构造形式会被当做重定向进行解释。
	当可用时，进程替换与参数和变量扩展，命令替换和算术表达式扩展会同时执行。

#### 单词分割 ####
	shell扫描没有出现在但引号中的参数扩展，命令扩展以及算术扩展来进行单词分割。
	shell会将$IFS作为分隔符进行处理来将其他扩展结果使用这些字符作为字段结束符进行分割。 如果IFS不存在或者其值为默认的<space><tab><newline>，那么之前扩展的结果中的开头和结尾的这些字符序列会被忽略，而其他位置IFS序列字符会为单词分割服务。如果IFS具有非默认字符，那么单词开头结尾的空白字符<space>和<tag>就会被忽略，尽管空白字符在IFS值中。任何非空白IFS字符以及任何连接IFS空白字符都会用来分割一个字段。一系列的IFS空白字符同样会被当做分割字符对待，如果ISF为null，不会有任何单词分割出现。
	显式的null参数会被保留，来自于参数扩展结果的非引用的隐式null参数被移除。如果参数没有任何在栓引号中扩展的值，就会得到一个null参数并且被保留。
	注意如果没有扩展出现，那么就不会执行分割。

#### 文件名扩展 ####
	在单词分割之后，除非设置了-f选项，bash会扫描每个单词来寻找'*','?'和'['字符。如果其中的一个字符出现，那么单词就会被当做一个pattern模式对待，并且使用字母表排序来对与模式匹配的文件名进行排序。如果没有找到匹配的文件名，并且shell的nullglob选项失效，那么单词会不进行任何改变。如果设置了nullglob选项，而且没有找到匹配的文件名，那么这个单词会被移除。如果failglob shell选项被设置，而没有任何匹配的文件，那么会打印一个错误的消息并且命令不会被执行。如果shell选项nocaseglob被生效，那么匹配就会忽略字母大小写。
	但一个pattern被用来进行文件名扩展，文件名开头的'.'字符以及紧跟的一个斜线/必须进行显式的匹配，除非shell选项dogglob被设置。当匹配一个文件名时，斜线字符必须总是显式的匹配，在另外的案例时，'.'字符不会被特殊对待。
	shell变量GLOBIGNORE可以用来限制与模式匹配的文件名集合，每个匹配的文件名如果同时与GLOBINGORE中的某个模式相匹配的话，就会从已匹配的列表中移除。文件名.和..在GLOBIGNORE被设置并且不会null总是被忽略。然而，将GLOBIGNORE设置为一个非null值会上dotglob选项生效，那么所有以.开头的文件名将会被匹配。为了得到忽略文件名开头为.的旧的行为，将'.*'作为GLOBIGNORE中的一个模式。dotglob选项在重置GLOBIGNORE时会失效。

##### 模式匹配 #####

#### 移除引用 ####

### shell重定向 ###
#### 输入重定向 ####
#### 输出重定向 ####
#### 追加重定向的输出 ####
#### 重定向标准输出/错误流 ####
#### 追加重定向的输入/错误流 ####
#### Here文档 ####
#### Here 字符串 ####
#### 复制文件描述符 ####
#### 移动文件描述符 ####
#### 打开文件描述符进行读写 ####


### 命令执行 ###
#### 简单命令扩展 ####
#### 命令搜索与执行 ####
#### 命令执行环境 ####
#### 环境 ####
#### 退出状态 ####
#### 信号 ####

### shell脚本 ###
