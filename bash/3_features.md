## 基本特性 ##


### shell语法 ###
  当shell读取输入时，它会进行一系列的处理操作。如果输入指示为注释的开头那么
shell就会忽略注释符号#，以及其所在行的剩余内容。否则，shell就会读取其输入
将其分为单词和操作符，并应用引用规则来选择相应的意义赋值给单词和字符。
  然后shell会将这些标记进行解释，将其翻译为命令，其他构造结构，移除特定单词
或字符的特殊含义，扩展其他单词或字符，必要的话或进行输出/入的重定向，执行指
定的命令，等待命令的退出状态，并使得退出状态为后续的检查或处理可用。
#### shell操作 ####
  以下是一个当shell读取并执行命令的相关操作的简单描述，基本上来说shell会具有
下面的操作：
	1. 从一个文件，一个为调用选项-c提供的作为参数的字符串，或者用户终端读取输入。
	2. 根据引用规则将其输入分为单词和操作符，这些标记通过元字符进行分割，在该步骤会执行别名扩展。
	3. 将上述标记翻译为简单或复合命令。
	4. 执行各种shell扩展，将扩展的标记分为文件名列表，命令和参数。
	5. 执行任意必要的重定向并从参数列表中移除重定向操作符以及其操作数。
	6. 执行命令
	7. 选择性地等待命令完成并收集其退出状态。
#### shell引用-quoting ####
	引用是用来移除特定字符或单词对于shell的特殊含义，引用可以用来让特殊字符的特殊处理失效，保护保留字，保护参数扩展。
	每个shell元字符对于shell来说都具有特殊的含义，因此在需要表示其本身的时候
需要使用引用。当命令历史扩展工具被使用时，历史扩展字符！，需要对其进行引用来防止其被历史命令扩展。shell中具有3中引用机制：转义字符，单引号，双引号。
##### 转义字符 #####
	一个没有被引起来的反斜线 \ 就是bash的转义字符，它会保留紧跟其后面字符的字面量值，但是对于newline除外。如果出现一个\newline对，并且\本身没有被引起来，此时\newline被作为续行处理。
##### 单引号 #####
	将字符包含在单引号内可以保留其中每个字符的字面量值，但是一个单引号不能出现在单引号之间，尽管具有一个前导反斜线\。

##### 双引号 #####
	包含在双引号中的字符会保留其中所有字符的字面量值，但是对于$,\，`和！(当历史扩展生效时)。 字符$,和 `在双引号中保留它们本身的特殊含义。在双引号中的\在其后面跟随以下字符（$,",\,newline,`）时保留其本身的含义-转义字符，因此当双引号中的\后面跟随这些字符时，不会显示\本身。双引号中可以通过\"的方式在其中使用双引号本身。如果历史命令扩展生效的话，那么双引号中的！会执行命令扩展，除非使用了前导转义字符对其进行转义。对于\!转义，不会移除其中的反斜线\。
	双引号中的特殊参数 * 和@具有特殊的含义。
##### ANSI-C 引用 #####
	对于$'string'形式的单词会被进行特殊的处理
##### 特定地区的翻译 #####
	TODO
#### shell注释 ####

### shell命令 ###
	一个简单的shell命令通常由命令以及使用空格分开的参数组成。
	更加复杂的命令是通过多种方法组合的一系列简单命令，这些方法有：管道，循环，条件控制以及其他分组。
#### 简单命令 ####
#### 管道 ####
	一个管道是通过控制操作符“|”或“|&”分开的一系列的简单命令.
	管道的形式为
		[time [-p]] [!] command1 [ | or |& command2 ] ...
	管道中的每个命令的输出都会通过管道连接到下一个命令的输入，也就是每个命令
都会读取前一个命令的输出。这个连接在通过命令指定任何重定向之前就被执行。
	如果使用|&，命令1的标准错误流和标准输出流会通过管道连接到命令2的输入，这
是对2>&1 |的缩写，隐含地在由命令指定的任何重定向之后执行将标准错误流重定向到
标准输出流。
	保留字time会在其完成之后将时间统计信息打印到管道，统计信息目前由命令执行消耗的时间，用户和系统消耗时间组成。
	-p选项会使用POSIX指定的输出格式。如果shell本身在POSIX模式中，如果time后面的标记以“-”开头，不会将time作为保留字对待。
	TIMEFORMAT变量可以用来设置时间信息显示的格式字符串。在shell内置中，shell函数以及管道中可以将time作为保留字使用。
	一个外部的time命令不会变得更容易使用。
	当shell在POSIX模式中时，time可能跟随一个newline，此时，shll显示shell以及其孩子执行消耗的所有用户和系统时间。TIMEFORMAT变量可能被用来指定时间信息格式。
	如果管道不是异步执行时，shell会等待管道中的每个命令完成。
	管道中的每个命令都是在其子shell中，管道的退出状态是管道中的最后一个命令的退出状态，除非pipefail选项生效。在pipefail选项
	生效时，管道的返回状态值是
#### 命令列表 ####
#### 复合命令 ####
##### 循环结构 ####
    1. until
        util test-commands; do consequent-commands; done
        
    2. while
        while test-commands; do consequent-commands; done
        
    3. for 
        for name [ [in [words ...] ] ; ] do commands; done
        
        for (( expr1 ; expr2 ; expr3 )) ; do commands ; done
        
##### 条件结构 #####
    
    1. if 
        if test-commands; then
            consequent-commands;
        [elif more-test-commands; then
            more-consequences;]
        [else alternate-consequents;
        fi 
        
    2. case
        case word in 
            [ [(] pattern [|pattern]...) command-list ;;]
            ...
        esac
        
    3. select
        
        select name [in words ...]; do commands; done
        
    4. ((...)
        (( expression ))
    
    5. [[...]]
        
        [[ expression ]]
##### 命令分组 #####
    1.()
        ( list )
    
    2.{}
        { list; }

#### 协同进程 ####
#### GNU并行 ####

### shell函数 ###

### shell参数 ###
#### 位置参数 ####
#### 特殊参数 ####
    
    $* 所有参数
    
    $@ 所有参数
    
    $# 参数个数
    
    $? 退出状态
    
    $- 当前选项标志

    $$ shell 进程ID
    
    $! 最近放入后台任务的进程ID
    
    $0 shell脚本文件名
    
    $_ 用来调用脚本的绝对路径名，或者被执行的脚本文件名
    



### shell扩展 ##
扩展在命令行将输入分割为标记之后开始执行，具有以下7中类型扩展：
    
    1. 括号扩展
    2. 波浪线扩展
    3. 参数和变量扩展
    4. 命令替换
    5. 算术扩展
    6. 单词分割
    7. 文件名扩展
扩展执行的顺序按照上述描述的顺序进行。

在有的系统上支持进程替换扩展，该扩展与2，3，4，5的执行时间相同。

只有括号扩展，单词分割和文件名扩展会改变扩展单词的数量，其他的扩展是
将单个单词扩展为单个单词， 唯一的例外是对$@的扩展和 ${name[@]}的扩展。

在所有扩展操作执行之后，引用移除动作被执行。

#### 括号扩展 ###
    括号扩展是一个生成任意字符串的机制，这个机制与文件名扩展相似，但是
生成的文件名不应该存在，括号扩展的模式具有一个可选的序言，跟随或者逗号
分割的字符串或者括号之间的表达式序列，然后跟随一个可选的后缀。序言会添
加到括号中每个字符串的前缀，后缀会添加到括号中每个字符串的后面，扩展操
作按照从左到右的顺序进行。
    
    括号扩展可以嵌套，每个扩展的字符串没有排序，默认为从左到右的顺序
    
    一个序列表达式的形式为 {x..y[..incr]}, x 和y可以是数字或单个字符，
incr是一个可选的增量，为整数。如果提供的是整数，那么表达式扩展为x和y
之间的每个数字，闭区间。提供的整数可以使用0作为前缀来强制等宽显示。如果
当x和y为0时，shell会强制所有生成的结果包含相同的数字
#### 波浪号~扩展 ####
#### shell参数扩展 ####
    $字符引入了参数扩展，命令替换或者算术扩展。要扩展的参数名称或符号可
能包含在括号中，这是可选的但是对于保护变量扩展不被其后紧跟的字符所影响是
非常重要的。
    当使用括号时，匹配的结束括号是第一个没有被转义的}字符或者在引起来的
字符串中，并且没有在嵌入的算术扩展中、命令替换或参数扩展中。
    
    基本的参数扩展形式为${parameter}. 参数的值会被替换，参数是一个之前描述
的shell参数或者数组引用。括号对于位置参数的位置不止一个数字时，或者参数名称
跟随一个字符不能将其解释为名称的一部分时。

    如果参数的第一个字符为感叹号！，它会引入一个变量间接级别，bash将之后的
参数变量值作为变量的名称，这个变量被扩展然后其值被作后续的替换，而不是参数本身
的值。这种被成为间接扩展，其中的例外包括了对 ${!prefix*}和 ${!name[@]}的扩展，
感叹号必须紧跟这左边括号一边引入间接扩展

    在下面的每个例子中，单词会使用波浪号扩展，参数扩展，命令替换以及算术扩展
    
    当不需要执行子串扩展，使用下面描述的形式，即 :-。 bash会测试一个参数是unset
或者null。忽略连接字符只会测试参数是否unset。也就是说，使用连接符号时，操作符会同时
测试参数是否存在并且其值是否为非null，如果忽略，操作符只测试参数的存在性。

    ${parameter:-word}
        如果参数不存在或者为null，扩展时使用word替换，否则使用参数值替换
        
    ${parameter:=word}
        如果参数不存在或者为null，参数的值变为word，然后使用参数的值进行替换，对于
        位置参数和特殊参数不能使用这种方式赋值。
        
    ${parameter:?word}
        如果参数不存在或者为null，扩展时word会被写入到标准错误流并且shell退出，如果是非交互模式的话。
        否则就使用参数的值进行替换
    
    ${parameter:+word}
        如果参数不存在或null，不会有任何替换否则使用word扩展替换。
        
    ${parameter:offset}
    ${parameter:offset:length}
        这会当作子串引用对待,它会根据offset指定的位置开始扩展到参数值的长度的字符，如果参数
        为@，或者关联数组的名称，那么结果会有所不同。如果未指定length，那么扩展的值会从offset
        指定的位置知道参数值的结尾。length和offset是算术表达式。
        如果offset的求解值是一个小于0的值，那么该值会作为从参数值末尾的字符偏移量。如果length
        的求解值是一个小于0的值，会被解释为参数值末尾的字符串的偏移量而不是作为字符数量，并且
        其扩展结果是在offset和这个结果之间的字符。注意负数偏移量的负号-需要与冒号之间存在一个
        空格以免引起混淆:-。
    
        如果参数为@，那么结果就是从offset开始的length个位置的参数。一个负数offset作为相对于
        最大位置参数处理，所有-1对应最后的一个位置参数，如果length求值是一个小于0的数会出现扩展错误。
        
        如果参数是一个索引位置数组@或*，那么结果就是length个从${paramter[offset]}的数组成员。一个负数的offset
        作为数组的最大索引位置的
        
        对于关联数组的子串扩展会产生未定义的结果。
        
        子串索引是一个基于0的除非位置参数被使用，此时索引默认以1作为开始。如果offset为0，
        并且使用位置参数，$@会作为列表的前缀。
        
    ${!prefix*}
    ${!prefix@}
        扩展为具有该前缀的变量名称，使用IFS特殊变量的第一个字符分割，当使用@时，扩展出现的结果
    在双引号内，每个变量名称扩展为一个分开的单词。
    
    ${!name[@]}
    ${!name[*]}
        如果名称是一个数组变量，扩展为名称中指定的数组索引或键值列表。如果name不是一个数组扩展为0如果
    name不存在或null。当使用@时，扩展出现在双引号内，每个键值被扩展为分开的单词。
    
    ${#parameter}
        参数值的长度被进行扩展替换，如果参数是*或@，那么值会被位置参数的个数替换。如果参数是一个数组名称
    并却具有下标*或@，会被数组元素的个数替换。如果patameter是一个索引数组名成并且具有一个负数下表索引值，
    那么该数字被解释相对参数最大索引的相对值，所以负数索引值按照从后向前的方式进行索引，-1作为最后一个元素
    索引。
    
    ${parameter#word}
    ${parameter##word
        如果word匹配parameter值的开头，那么扩展后的结果就是对于#取删除word最小匹配后的值，对于##取删除word最大匹配后的值。
        如果参数为@或\*，那么删除操作会匹配到每个位置参数上，然后返回相应的结果列表值。如果参数是数组变量具有@或\*下标,那么
        删除操作为应用到数组的每个元素上然后返回新的数组。
    
    ${
        
    
#### 命令替换 ####
#### 算术运算扩展 ####
#### 进程替换扩展 ####
#### 单词分割 ####
#### 文件名扩展 ####
##### 模式匹配 #####
#### 移除引用 ####

### shell重定向 ###
#### 输入重定向 ####
#### 输出重定向 ####
#### 追加重定向的输出 ####
#### 重定向标准输出/错误流 ####
#### 追加重定向的输入/错误流 ####
#### Here文档 ####
#### Here 字符串 ####
#### 复制文件描述符 ####
#### 移动文件描述符 ####
#### 打开文件描述符进行读写 ####


### 命令执行 ###
#### 简单命令扩展 ####
#### 命令搜索与执行 ####
#### 命令执行环境 ####
#### 环境 ####
#### 退出状态 ####
#### 信号 ####

### shell脚本 ###
